#!/usr/bin/python3

# Copyright (c) 2014, Pavel Å imerda <pavlix@pavlix.net>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies, 
# either expressed or implied, of the FreeBSD Project.

import os, sys, logging

logging.basicConfig(log_level=logging.DEBUG, style="{", format="systemd2rc: {message}")
log = logging.getLogger()
log.setLevel(logging.DEBUG)

class ConversionError(Exception):
    pass

class Option:
    def __init__(self, name):
        self.name = name
        self.values = []

    def add(self, *values):
        self.values += values

    def __str__(self):
        return '{} = {}'.format(self.name, self.value)

    @property
    def value(self):
        return ' '.join(self.values)

class Section:
    def __init__(self, name):
        self.name = name
        self.options = {}
        self.processed = set()

    def add(self, name, *values):
        for value in values:
            self.options.setdefault(name, Option(name)).add(value)

    def __lt__(self, other):
        return self.name < other.name

    def __str__(self):
        return self.name

    def __getitem__(self, name):
        option = self.options[name]

        log.debug("Processing: {}.{}".format(self.name, option))
        self.processed.add(name)

        return option

    @property
    def unprocessed(self):
        return iter(item for item in self.options if item not in self.processed)

class Unit:
    dep_types = ["Requisite", "Requires", "Wants", "Before", "After"]
    inline_multi_whitelist = [("Unit", dep_type) for dep_type in dep_types]

    def __init__(self, path):
        self.path = path
        self.name = os.path.split(path)[1].split('.')[0]
        self.sections = {}

        log.debug("Reading file: {!r}".format(path))

        with open(path) as stream:
            for line in stream:
                if line.startswith('['):
                    name = line.strip('[] \t\r\n')
                    section = self.sections[name] = Section(name)
                elif '=' in line:
                    name, value = (s.strip() for s in line.split('=', 1))
                    if (section.name, name) in self.inline_multi_whitelist:
                        section.add(name, *value.split())
                    else:
                        section.add(name, value)

    def __iter__(self):
        return iter(self.sections.values())

    def get(self, section, option, default=ConversionError, multi=False):
        try:
            option = self.sections[section][option]
            return option.values if multi else option.value
        except KeyError:
            if default is ConversionError:
                raise ConversionError("Missing option {}.{}".format(section, option))
            return default

class Output:
    def __init__(self, unit):
        self.unit = unit

    def __str__(self):
        return ''.join(iter(self))

class GentooInitScript(Output):
    HEADER = ''.join((
            "#!/sbin/runscript\n#\n",
            "# Generated by: {generator}\n# Generated from: {unit.path}\n#\n"
            "# Description: {description}\n\n"))

    def __init__(self, unit, pidfile=None):
        super().__init__(unit)

        self.generator = "systemd2rc (using the gentoo initscript generator)"
        self.description = self.unit.get("Unit", "Description", "")
        self.service_type = self.unit.get("Service", "Type", "simple")

        # treat dbus services as simple
        log.warning("Treating a dbus service as a simple service.")
        if self.service_type == "dbus":
            self.service_type = "simple"

        self.pidfile = pidfile or "/run/{}.pid".format(self.unit.name)

    def __iter__(self):
        yield self.HEADER.format(**vars(self))

        for pattern in "do_variables_{}", "do_depend", "do_startstop_{}":
            helper = getattr(self, pattern.format(self.service_type), None)
            if (helper):
                yield from helper()

        unprocessed = sum([[(section.name, option) for option in section.unprocessed] for section in sorted(self.unit)], [])

        if unprocessed:
            yield "# Ignored directives:\n#\n"
            for section, option in unprocessed:
                yield "#  * {}.{}\n".format(section, option)
            yield "#\n"

    def do_depend(self):
        services = {}
        unsupported_deps = []

        for dep_type in self.unit.dep_types:
            for service in self.unit.get("Unit", dep_type, default=(), multi=True):
                if service == "network.target":
                    service = "net"
                elif service.endswith(".service"):
                    service = service[:-8]
                elif "." in service:
                    unsupported_deps.append((service, dep_type))
                    continue
                services.setdefault(service, set()).add(dep_type)

        if services:
            yield "depend() {\n"
            for service, deps in sorted(services.items()):
                if "Requisite" in deps or "Requires" in deps:
                    yield "    need {}\n".format(service)
                elif "Wants" in deps:
                    yield "    use {}\n".format(service)
                elif "Before" in deps:
                    yield "    before {}\n".format(service)
                elif "After" in deps:
                    yield "    after {}\n".format(service)
                else:
                    raise ValueError("Bad dependency set: {}".format(deps))
            yield "}\n\n"

        if unsupported_deps:
            yield "# Ignored dependencies:\n#\n"
            for service, dep_type in unsupported_deps:
                yield "#  * {} = {}\n".format(dep_type, service)
            yield "#\n\n"

    def do_variables(self, startopts="", stopopts=""):
        yield 'COMMAND="{}"\n'.format(self.unit.get("Service", "ExecStart", multi=True)[0])
        yield 'PIDFILE="{}"\n'.format(self.pidfile)
        yield 'STARTOPTS="--start --make-pidfile --background --quiet"\n'
        yield 'STOPOPTS="--quiet"\n\n'

    def do_variables_simple(self):
        yield from self.do_variables(startopts="--start --make-pidfile --background --quiet", stopopts="--quiet")

    def do_variables_forking(self):
        yield from self.do_variables()

    def do_startstop_oneshot(self):
        yield 'start() {\n    ebegin "Starting $SVCNAME"\n'
        yield from self.do_commands("ExecStartPre")
        yield from self.do_commands("ExecStart")
        yield from self.do_commands("ExecStartPost")
        yield '    eend 0\n}\n\n'

    def do_startstop_simple(self):
        yield 'start() {\n    ebegin "Starting $SVCNAME"\n'
        yield from self.do_commands("ExecStartPre")
        yield '    start-stop-daemon --start $STARTOPTS --pidfile "$PIDFILE" -- $COMMAND || error\n'
        yield from self.do_commands("ExecStartPost")
        yield '    eend 0\n}\n\n'
        yield 'stop() {\n    ebegin "Stopping $SVCNAME"\n'
        yield from self.do_commands("ExecStopPre")
        yield '    start-stop-daemon --stop $STOPOPTS --pidfile "$PIDFILE"\n'
        yield from self.do_commands("ExecStopPost")
        yield '    eend 0\n}\n\n'
        yield 'reload() {\n    ebegin "Reloading $SVCNAME"\n'
        yield '    start-stop-daemon --signal HUP --pidfile "$PIDFILE" || error\n'
        yield '    eend 0\n}\n\n'
        yield 'error() {\n'
        yield '    start-stop-daemon --signal KILL --pidfile "$PIDFILE"\n'
        yield '    eend 1\n}\n\n'

    def do_commands(self, option_name):
        for command in self.unit.get("Service", option_name, multi=True, default=[]):
            if command.startswith('-'):
                yield "    {}\n".format(command[1:])
            else:
                yield "    {} || error\n".format(command)

def usage():
    exit("Usage: systemd2rc [ --pidfile <pidfile> ] <path>")

if __name__ == '__main__':
    path = None
    pidfile = None

    sys.argv.pop(0)
    while sys.argv:
        arg = sys.argv.pop(0)
        if arg == '--pidfile':
            pidfile = sys.argv.pop(0)
        elif not path and not arg.startswith('-'):
            path = arg
        else:
            usage()

    if not path:
        usage()

    sys.stdout.write(str(GentooInitScript(Unit(path), pidfile=pidfile)))
